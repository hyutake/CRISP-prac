{"ast":null,"code":"import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nexport const fetchTasks = createAsyncThunk(\"task/fetchTasks\", async () => {\n  try {\n    const response = await fetch(\"http://localhost:3001/tasks\");\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch tasks from the API.\");\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.log(error);\n    throw error;\n  }\n});\nconst taskSlice = createSlice({\n  name: \"task\",\n  initialState: {\n    tasks: [],\n    quantity: 0\n  },\n  reducers: {\n    addTask(state, action) {\n      // action will pass an entire task object\n      const task = action.payload;\n      state.tasks.push({\n        id: 't' + Math.random().toString(),\n        title: task.title,\n        desc: task.desc,\n        deadline: task.deadline\n      });\n      state.tasks.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));\n      state.quantity++;\n    },\n    removeTask(state, action) {\n      // action will pass the id of a task\n      const id = action.payload;\n\n      // double confirm deletion\n      const proceed = window.confirm(\"Delete task?\");\n      if (proceed) {\n        state.tasks = state.tasks.filter(task => task.id !== id);\n        state.quantity--;\n      }\n    },\n    editTask(state, action) {\n      // action will pass the edited task\n      const editedTask = action.payload;\n      console.log(\"editedTask.id:\");\n      console.log(editedTask.id);\n\n      // find the matching task stored in the redux context\n      const existingTask = state.tasks.find(task => task.id === editedTask.id);\n      if (!existingTask) {\n        console.log(\"Task does not exist wtf?\");\n      }\n\n      // update values...?\n      existingTask.title = editedTask.title;\n      existingTask.desc = editedTask.desc;\n      existingTask.deadline = editedTask.deadline;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchTasks.fulfilled, (state, action) => {\n      state.tasks = action.payload;\n      state.quantity = action.payload.length;\n    });\n  }\n});\nexport const taskActions = {\n  ...taskSlice.actions,\n  fetchTasks\n};\nexport default taskSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","fetchTasks","response","fetch","ok","Error","data","json","error","console","log","taskSlice","name","initialState","tasks","quantity","reducers","addTask","state","action","task","payload","push","id","Math","random","toString","title","desc","deadline","sort","a","b","Date","removeTask","proceed","window","confirm","filter","editTask","editedTask","existingTask","find","extraReducers","builder","addCase","fulfilled","length","taskActions","actions","reducer"],"sources":["/Users/matthewsamynathan/Documents/GitHub/CRISP-prac/frontend/src/store/task-slice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\n\nexport const fetchTasks = createAsyncThunk(\"task/fetchTasks\", async () => {\n  try {\n    const response = await fetch(\"http://localhost:3001/tasks\");\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch tasks from the API.\");\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.log(error);\n    throw error;\n  }\n});\n\nconst taskSlice = createSlice({\n  name: \"task\",\n  initialState: {\n    tasks: [],\n    quantity: 0,\n  },\n  reducers: {\n\taddTask(state, action) {\n\t\t// action will pass an entire task object\n\t\tconst task = action.payload;\n\n\t\tstate.tasks.push({\n\t\t\tid: 't' + Math.random().toString(),\n\t\t\ttitle: task.title,\n\t\t\tdesc: task.desc,\n\t\t\tdeadline: task.deadline\n\t\t});\n\t\tstate.tasks.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));\n\t\tstate.quantity++;\n\t},\n\tremoveTask(state, action) {\n\t\t// action will pass the id of a task\n\t\tconst id = action.payload;\n\n\t\t// double confirm deletion\n\t\tconst proceed = window.confirm(\"Delete task?\");\n\n\t\tif(proceed) {\n\t\t\tstate.tasks = state.tasks.filter((task) => task.id !== id);\n\t\t\tstate.quantity--;\n\t\t}\n\t},\n\teditTask(state, action){\n\t\t// action will pass the edited task\n\t\tconst editedTask = action.payload;\n\t\tconsole.log(\"editedTask.id:\");\n\t\tconsole.log(editedTask.id);\n\t\t\n\t\t// find the matching task stored in the redux context\n\t\tconst existingTask = state.tasks.find((task) => task.id === editedTask.id);\n\n\t\tif(!existingTask) {\n\t\t\tconsole.log(\"Task does not exist wtf?\");\n\t\t}\n\n\t\t// update values...?\n\t\texistingTask.title = editedTask.title;\n\t\texistingTask.desc = editedTask.desc;\n\t\texistingTask.deadline = editedTask.deadline;\n\t}  \n},\n  extraReducers: (builder) => {\n    builder.addCase(fetchTasks.fulfilled, (state, action) => {\n      state.tasks = action.payload;\n      state.quantity = action.payload.length;\n    });\n  },\n});\n\nexport const taskActions = { ...taskSlice.actions, fetchTasks };\nexport default taskSlice.reducer;\n\n\n\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,gBAAgB,QAAQ,kBAAkB;AAEhE,OAAO,MAAMC,UAAU,GAAGD,gBAAgB,CAAC,iBAAiB,EAAE,YAAY;EACxE,IAAI;IACF,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAAC,6BAA6B,CAAC;IAC3D,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;IACxD;IACA,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IAClC,OAAOD,IAAI;EACb,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;IAClB,MAAMA,KAAK;EACb;AACF,CAAC,CAAC;AAEF,MAAMG,SAAS,GAAGZ,WAAW,CAAC;EAC5Ba,IAAI,EAAE,MAAM;EACZC,YAAY,EAAE;IACZC,KAAK,EAAE,EAAE;IACTC,QAAQ,EAAE;EACZ,CAAC;EACDC,QAAQ,EAAE;IACXC,OAAOA,CAACC,KAAK,EAAEC,MAAM,EAAE;MACtB;MACA,MAAMC,IAAI,GAAGD,MAAM,CAACE,OAAO;MAE3BH,KAAK,CAACJ,KAAK,CAACQ,IAAI,CAAC;QAChBC,EAAE,EAAE,GAAG,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;QAClCC,KAAK,EAAEP,IAAI,CAACO,KAAK;QACjBC,IAAI,EAAER,IAAI,CAACQ,IAAI;QACfC,QAAQ,EAAET,IAAI,CAACS;MAChB,CAAC,CAAC;MACFX,KAAK,CAACJ,KAAK,CAACgB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIC,IAAI,CAACF,CAAC,CAACF,QAAQ,CAAC,GAAG,IAAII,IAAI,CAACD,CAAC,CAACH,QAAQ,CAAC,CAAC;MACvEX,KAAK,CAACH,QAAQ,EAAE;IACjB,CAAC;IACDmB,UAAUA,CAAChB,KAAK,EAAEC,MAAM,EAAE;MACzB;MACA,MAAMI,EAAE,GAAGJ,MAAM,CAACE,OAAO;;MAEzB;MACA,MAAMc,OAAO,GAAGC,MAAM,CAACC,OAAO,CAAC,cAAc,CAAC;MAE9C,IAAGF,OAAO,EAAE;QACXjB,KAAK,CAACJ,KAAK,GAAGI,KAAK,CAACJ,KAAK,CAACwB,MAAM,CAAElB,IAAI,IAAKA,IAAI,CAACG,EAAE,KAAKA,EAAE,CAAC;QAC1DL,KAAK,CAACH,QAAQ,EAAE;MACjB;IACD,CAAC;IACDwB,QAAQA,CAACrB,KAAK,EAAEC,MAAM,EAAC;MACtB;MACA,MAAMqB,UAAU,GAAGrB,MAAM,CAACE,OAAO;MACjCZ,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;MAC7BD,OAAO,CAACC,GAAG,CAAC8B,UAAU,CAACjB,EAAE,CAAC;;MAE1B;MACA,MAAMkB,YAAY,GAAGvB,KAAK,CAACJ,KAAK,CAAC4B,IAAI,CAAEtB,IAAI,IAAKA,IAAI,CAACG,EAAE,KAAKiB,UAAU,CAACjB,EAAE,CAAC;MAE1E,IAAG,CAACkB,YAAY,EAAE;QACjBhC,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;MACxC;;MAEA;MACA+B,YAAY,CAACd,KAAK,GAAGa,UAAU,CAACb,KAAK;MACrCc,YAAY,CAACb,IAAI,GAAGY,UAAU,CAACZ,IAAI;MACnCa,YAAY,CAACZ,QAAQ,GAAGW,UAAU,CAACX,QAAQ;IAC5C;EACD,CAAC;EACCc,aAAa,EAAGC,OAAO,IAAK;IAC1BA,OAAO,CAACC,OAAO,CAAC5C,UAAU,CAAC6C,SAAS,EAAE,CAAC5B,KAAK,EAAEC,MAAM,KAAK;MACvDD,KAAK,CAACJ,KAAK,GAAGK,MAAM,CAACE,OAAO;MAC5BH,KAAK,CAACH,QAAQ,GAAGI,MAAM,CAACE,OAAO,CAAC0B,MAAM;IACxC,CAAC,CAAC;EACJ;AACF,CAAC,CAAC;AAEF,OAAO,MAAMC,WAAW,GAAG;EAAE,GAAGrC,SAAS,CAACsC,OAAO;EAAEhD;AAAW,CAAC;AAC/D,eAAeU,SAAS,CAACuC,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}